local user_progress = require "game.common.user_progress"
local levels_holder = require "game.common.levels_holder"
local messages = require "game.common.messages"

local input_stack = require "game.game.input_stack"
local grid_controller = require "game.game.grid_controller"


local normal_cell_color = vmath.vector4(0.9, 0.9, 0.8, 1)
local active_cell_color = vmath.vector4(0, 0.9, 0.9, 1)


function init(self)
    msg.post(".", "acquire_input_focus")
    input_stack:reset()
    grid_controller:reset()
end


local function get_cell_root(cell)
    return cell[grid_controller.hash_cell_root]
end


local function add_active_cell(self, cell)
    input_stack:push(cell)
    gui.animate(get_cell_root(cell), gui.PROP_COLOR, active_cell_color, gui.EASING_LINEAR, 0.15)
end


local function pop_active_cell(self)
    local cell = input_stack:pop()
    if cell then
        gui.animate(get_cell_root(cell), gui.PROP_COLOR, normal_cell_color, gui.EASING_LINEAR, 0.15)
        return true
    end
end


local function finish_input(self)
    while pop_active_cell(self) do end
end


-- returns true if the input set was changed
local function update_input(self, pos_x, pos_y)

    local cell, cell_x, cell_y = grid_controller:get_cell_at_screen_pos(pos_x, pos_y)

    if cell then

        -- check for very rare (but still possible) case - diagonal movement
        local last_cell = input_stack:top()
        if last_cell then
            local last_cell_x, last_cell_y = grid_controller:get_grid_pos(last_cell)
            local manhattan_dist = math.abs(last_cell_x - cell_x) + math.abs(last_cell_y - cell_y)
            if manhattan_dist >= 2 then
                -- clear_active_cells(self)
                return false
            end
        end

        -- check if we came back to the penultimate cell (then remove the last one)
        if input_stack:contains(cell) then
            if input_stack:index_of(cell) == input_stack:size() - 1 then
                pop_active_cell(self)
                return true
            end
        else
            add_active_cell(self, cell)
            return true
        end
    end
    return false
end


function on_input(self, action_id, action)

    if not grid_controller.is_ready then
        return
    end

    if action_id == hash("touch") then
        if action.pressed then
            update_input(self, action.x, action.y)
        elseif action.released then
            finish_input(self)
        end
    elseif action_id == nil and input_stack:size() > 0 then
        -- mouse movement with the pressed button
        update_input(self, action.x, action.y)
    end
end


function on_message(self, message_id, message, sender)
    if message_id == messages.START_NEW_LEVEL then
        print(messages.START_NEW_LEVEL)
    elseif message_id == messages.CREATE_LEVEL_GRID then
        input_stack:reset()
        grid_controller:create_grid()
    end
end
