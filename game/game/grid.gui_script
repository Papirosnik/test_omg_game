
local messages = require "game.common.messages"
local grid_context = require "game.game.grid_context"
local input_context = require "game.game.input_context"



local normal_cell_color = vmath.vector4(0.9, 0.9, 0.8, 1)
local active_cell_color = vmath.vector4(0, 0.9, 0.9, 1)


function init(self)
    msg.post(".", "acquire_input_focus")
    input_context:reset()
    grid_context:reset()
end


local function get_cell_root(cell)
    return cell[grid_context.hash_cell_root]
end


local function add_to_input(self, cell)
    if input_context:push(cell) then
        gui.animate(get_cell_root(cell), gui.PROP_COLOR, active_cell_color, gui.EASING_LINEAR, 0.15)
        msg.post("/game/game#game_gui", messages.INPUT_CHANGED, { input = input_context.data })
        return true
    end
end


local function remove_last_input(self)
    local cell = input_context:pop()
    if cell then
        gui.animate(get_cell_root(cell), gui.PROP_COLOR, normal_cell_color, gui.EASING_LINEAR, 0.15)
        msg.post("/game/game#game_gui", messages.INPUT_CHANGED, { input = input_context.data })
        return true
    end
end


local function finish_input(self, do_check_words)
    if do_check_words then
        msg.post("/game/game#game_gui", messages.INPUT_COMPLETED)
    end
    while remove_last_input(self) do end
end


-- returns true if the input set was changed
local function update_input(self, pos_x, pos_y)

    local cell, cell_x, cell_y = grid_context:get_cell_by_screen_pos(pos_x, pos_y)
    if not cell then return end

    -- check for very rare (but still possible) case - diagonal movement
    local last_cell = input_context:top()
    if last_cell then
        local last_cell_x, last_cell_y = grid_context:get_cell_pos(last_cell)
        local manhattan_dist = math.abs(last_cell_x - cell_x) + math.abs(last_cell_y - cell_y)
        if manhattan_dist >= 2 then
            return false
        end
    end

    -- check if we came back to the penultimate cell (then remove the last one)
    if input_context:contains(cell) then
        if input_context:index_of(cell) == input_context:size() - 1 then
            remove_last_input(self)
            sound.play("/main#sound_negative", {pan = 0.0, gain = 0.1})
            return true
        end
    else
        if add_to_input(self, cell) then
            sound.play("/main#sound_beep", {pan = 0.0, gain = 0.1})
            return true
        end
    end
end


function on_input(self, action_id, action)

    if not grid_context.is_ready then
        return
    end

    if action_id == hash("touch") then
        if action.pressed then
            update_input(self, action.x, action.y)
        elseif action.released then
            local inside_grid = (grid_context:get_cell_by_screen_pos(action.x, action.y) ~= nil)
            finish_input(self, inside_grid)
        end
    elseif action_id == nil and input_context:size() > 0 then
        -- mouse movement with the pressed button
        update_input(self, action.x, action.y)
    end
end


function on_message(self, message_id, message, sender)
    if message_id == messages.START_NEW_LEVEL then
        print(messages.START_NEW_LEVEL)
    elseif message_id == messages.LEVEL_CHANGED then
        input_context:reset()
        grid_context:create_grid()
    end
end
