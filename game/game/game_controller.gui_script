local user_progress = require "game.common.user_progress"
local current_level = require "game.game.current_level"
local messages = require "game.common.messages"
local input_storage = require "game.game.input_storage"
local words_storage = require "game.game.words_storage"



function init(self)
    -- profiler.enable_ui(true)
    msg.post(".", "acquire_input_focus")
    self.root_node = gui.get_node("root")
    self.txt_current_level = gui.get_node("txt_current_level")
    self.txt_current_word = gui.get_node("txt_current_word")
    self.box_bonus_words = gui.get_node("bonus_words")
    self.txt_bonus_words = gui.get_node("txt_bonus_words")
    self.btn_skip_level = gui.get_node("btn_skip_level")
    self.btn_reset_bonus = gui.get_node("btn_reset_bonus")
    self.txt_show_info = gui.get_node("txt_show_info")
    current_level:load_by_index(user_progress.data.current_level)
    input_storage:reset()
    words_storage:init()
end


---------------- message handlers ---------------
local function load_level(self, index)
    self.win = false
    gui.set_enabled(self.root_node, true)
    gui.set_text(self.txt_current_level, "Level " .. current_level:get().name)
    msg.post("#", messages.UPDATE_BONUS_COUNT)
    msg.post("/game/grid#grid_gui", messages.LOAD_LEVEL, { ["index"] = index })
end


local function hide_info(self)
    gui.cancel_animation(self.txt_show_info, gui.PROP_COLOR)
    gui.animate(self.txt_show_info, "color.w", 0, gui.EASING_LINEAR, 0.25)
end


local function show_info(self, text, duration)
    duration = duration or 3
    gui.cancel_animation(self.txt_show_info, gui.PROP_COLOR)
    gui.set_text(self.txt_show_info, text)
    local fn_hide = function() gui.animate(self.txt_show_info, "color.w", 0, gui.EASING_LINEAR, 0.5, duration) end
    gui.animate(self.txt_show_info, "color.w", 1, gui.EASING_INCIRC, 0.25, 0, fn_hide)
end


local function skip_level(self)
    user_progress:set_next_level()
    current_level:load_by_index(user_progress.data.current_level)
end


local function update_input(self, input)
    gui.set_text(self.txt_current_word, input)
end


local function check_word(self, input)
    current_level:check_word(input)
end


local function word_accepted(self, word, way, index)
    show_info(self, "FOUND!")
    sound.play("/main#sound_word", {pan = 0.0, gain = 0.5})
    msg.post("/game/grid#grid_gui", messages.WORD_ACCEPTED, { ["word"] = word, ["way"] = way, ["index"] = index })
end


local function word_rejected(self)
    sound.play("/main#sound_negative", {pan = 0.0, gain = 0.5})
    msg.post("/game/grid#grid_gui", messages.WORD_REJECTED)
end


local function try_another_way(self)
    sound.play("/main#sound_negative", {pan = 0.0, gain = 0.5})
    msg.post("/game/grid#grid_gui", messages.TRY_ANOTHER_WAY)
    show_info(self, "TRY TO COLLECT THIS WORD IN ANOTHER WAY")
end


local function update_bonus_word_counter(self)
    local when_done = function()
        gui.set_text(self.txt_bonus_words, "Bonus words: "..user_progress:total_bonus_words())
    end
    gui.animate(self.box_bonus_words, gui.PROP_SCALE, 1.1, gui.EASING_INOUTCIRC, 0.75, 0, when_done, gui.PLAYBACK_ONCE_PINGPONG)
end


local function bonus_word_found(self, word)
    if user_progress:check_bonus_word(word) then
        show_info(self, "ALREADY COLLECTED")
        sound.play("/main#sound_negative", {pan = 0.0, gain = 0.5})
    else
        show_info(self, "BONUS WORD FOUND!")
        sound.play("/main#sound_word", {pan = 0.0, gain = 0.5})
        user_progress:add_bonus_word(word)
    end
end


local function celebrate_win(self)
    self.win = true
    local postponed_action = function()
        sound.play("/main#sound_win", { pan = 0.0, gain = 0.5 })
        show_info(self, "CONGRATULATIONS!", 100500) -- show congrats forever
        msg.post("/game/grid#grid_gui", messages.LEVEL_COMPLETE)
    end
    timer.delay(2, false, postponed_action)
end


local function unload_level(self)
    user_progress:set_next_level()
    local fn_done = function()
        gui.set_scale(self.root_node, vmath.vector3(1))
        gui.set_enabled(self.root_node, false)
        msg.post("/main#main", messages.START_LEVEL_SELECTION)
    end
    gui.animate(self.root_node, "scale.x", -1, gui.EASING_INBACK, 0.5, 0, fn_done)
end


local function on_button_press(btn_node)
    gui.animate(btn_node, gui.PROP_SCALE, vmath.vector3(0.85), gui.EASING_LINEAR, 0.07)
    sound.play("/main#sound_click", {pan = 0.0})
end

local function on_button_release(btn_node)
    gui.animate(btn_node, gui.PROP_SCALE, vmath.vector3(1), gui.EASING_LINEAR, 0.07)
end

function on_input(self, action_id, action)
    if action_id == hash("touch") and not self.win then
        local inside_skip_button = gui.pick_node(self.btn_skip_level, action.x, action.y)
        local inside_reset_bonus = gui.pick_node(self.btn_reset_bonus, action.x, action.y)
        if action.pressed then
            if inside_skip_button then
                on_button_press(self.btn_skip_level)
            elseif inside_reset_bonus then
                on_button_press(self.btn_reset_bonus)
            end
        elseif action.released then
            on_button_release(self.btn_skip_level)
            on_button_release(self.btn_reset_bonus)
            if inside_skip_button then
                skip_level(self)
            elseif inside_reset_bonus then
                user_progress:reset_bonus_words()
            end
        end
    end
end


function on_message(self, message_id, message, sender)
    if message_id == messages.LOAD_LEVEL then
        load_level(self, message.index)
    elseif message_id == messages.SHOW_INFO then
        show_info(self, message.text)
    elseif message_id == messages.HIDE_INFO then
        hide_info(self)
    elseif message_id == messages.INPUT_CHANGED then
        update_input(self, message.input)
    elseif message_id == messages.INPUT_COMPLETED then
        check_word(self, message.input)
    elseif message_id == messages.WORD_ACCEPTED then
        word_accepted(self, message.word, message.way, message.index)
    elseif message_id == messages.WORD_REJECTED then
        word_rejected(self)
    elseif message_id == messages.TRY_ANOTHER_WAY then
        try_another_way(self)
    elseif message_id == messages.BONUS_WORD_FOUND then
        bonus_word_found(self, message.word)
    elseif message_id == messages.UPDATE_BONUS_COUNT then
        update_bonus_word_counter(self)
    elseif message_id == messages.LEVEL_COMPLETE then
        celebrate_win(self)
    elseif message_id == messages.UNLOAD_LEVEL then
        unload_level(self)
    end
end
